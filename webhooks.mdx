---
title: "Webhooks"
description: "Receive real-time push notifications when orders complete or fail"
---

Webhooks deliver HTTP `POST` callbacks to your server when order processing completes or fails. Use webhooks instead of polling the [Get Order](/api-reference/orders/get-order) endpoint — your server gets notified the moment a result is ready.

## Setting up webhooks

<Steps>
  <Step title="Register a webhook endpoint">
    Create a webhook using the [Create Webhook](/api-reference/webhooks/create-webhook) API:

    ```bash
    curl -X POST https://morimori.app/api/v2/orders/webhooks \
      -H "Authorization: Bearer YOUR_API_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "name": "My Webhook",
        "url": "https://your-server.com/webhook"
      }'
    ```

    **Response:**
    ```json
    {
      "data": {
        "id": 1,
        "name": "My Webhook",
        "secret": "whsec_xxxxxxxxxxxxxxxxxx"
      }
    }
    ```

    <Warning>
      Save the `secret` immediately — **it is shown only once** and cannot be retrieved again. You need it to verify every incoming webhook signature.
    </Warning>
  </Step>
  <Step title="Implement your endpoint">
    Your webhook handler must:
    - Accept `POST` requests with a JSON body
    - Respond with a `2xx` status code within **5 seconds**
    - Verify the `X-MoriBiz-Signature` header before processing
  </Step>
  <Step title="Verify signatures">
    Every request includes an `X-MoriBiz-Signature` header. See [Signature Verification](#signature-verification) below for implementation in your language.
  </Step>
</Steps>

## Event types

| Event Type | Description |
|-----------|-------------|
| `order.antiAi.completed` | Anti-AI processing completed successfully |
| `order.antiAi.failed` | Anti-AI processing failed |
| `order.watermarkEmbed.completed` | Watermark embedding completed successfully |
| `order.watermarkEmbed.failed` | Watermark embedding failed |
| `order.watermarkExtract.completed` | Watermark extraction completed successfully |
| `order.watermarkExtract.failed` | Watermark extraction failed |

## Webhook payload

All webhook payloads follow this structure:

```json
{
  "eventType": "order.antiAi.completed",
  "occurredAt": "2026-02-19T12:00:00.000Z",
  "data": {
    "orderId": "123456789",
    "orderName": "anti_ai_2026-02-19",
    "createdAt": "2026-02-19T11:50:00.000Z",
    "completedAt": "2026-02-19T12:00:00.000Z",
    "status": "complete",
    "fileCount": 3,
    "downloadUrl": "https://s3.amazonaws.com/..."
  }
}
```

### Completed event data

| Field | Type | Description |
|-------|------|-------------|
| `orderId` | string | Order ID |
| `orderName` | string | Order name |
| `createdAt` | string | Order creation time (ISO 8601) |
| `completedAt` | string | Processing completion time (ISO 8601) |
| `status` | string | `complete`, `detected`, or `undetected` |
| `fileCount` | integer | Number of processed files |
| `downloadUrl` | string | Result file download URL (valid for 1 hour) |

### Failed event data

| Field | Type | Description |
|-------|------|-------------|
| `orderId` | string | Order ID |
| `orderName` | string | Order name |
| `createdAt` | string | Order creation time (ISO 8601) |
| `failedAt` | string | Processing failure time (ISO 8601) |
| `status` | string | Always `failed` |
| `error.code` | string | Error code |
| `error.message` | string | Error message |

### Watermark extract completed

For watermark extract orders, the completed event includes additional fields:

| Field | Type | Description |
|-------|------|-------------|
| `status` | string | `detected` or `undetected` |
| `watermarkFound` | boolean | Whether a watermark was detected |
| `watermarkInfo.text` | string | Detected watermark text (only when `watermarkFound` is true) |

## Signature verification

Verify webhook authenticity by checking the `X-MoriBiz-Signature` header. Always verify **before** processing the event.

<CodeGroup>
```javascript Node.js
const crypto = require('crypto');

function verifyWebhookSignature(rawBody, signature, secret) {
  const expected = crypto
    .createHmac('sha256', secret)
    .update(rawBody)          // use the raw request body string
    .digest('hex');

  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expected)
  );
}

// Express handler
app.post('/webhook', express.raw({ type: 'application/json' }), (req, res) => {
  const signature = req.headers['x-moribiz-signature'];

  if (!verifyWebhookSignature(req.body.toString(), signature, process.env.WEBHOOK_SECRET)) {
    return res.status(401).send('Invalid signature');
  }

  const { eventType, data } = JSON.parse(req.body);
  console.log(`Received ${eventType} for order ${data.orderId}`);
  res.sendStatus(200);
});
```

```python Python
import hmac
import hashlib

def verify_webhook_signature(raw_body: str, signature: str, secret: str) -> bool:
    expected = hmac.new(
        secret.encode(),
        raw_body.encode(),
        hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(signature, expected)

# Flask handler
from flask import Flask, request, abort
import json

app = Flask(__name__)

@app.route('/webhook', methods=['POST'])
def webhook():
    signature = request.headers.get('X-MoriBiz-Signature')
    raw_body  = request.get_data(as_text=True)

    if not verify_webhook_signature(raw_body, signature, os.environ['WEBHOOK_SECRET']):
        abort(401)

    event = json.loads(raw_body)
    return '', 200
```

```php PHP
<?php
function verifyWebhookSignature(string $rawBody, string $signature, string $secret): bool {
    $expected = hash_hmac('sha256', $rawBody, $secret);
    return hash_equals($expected, $signature);
}

$signature = $_SERVER['HTTP_X_MORIBIZ_SIGNATURE'] ?? '';
$rawBody   = file_get_contents('php://input');

if (!verifyWebhookSignature($rawBody, $signature, getenv('WEBHOOK_SECRET'))) {
    http_response_code(401);
    exit('Unauthorized');
}

$event = json_decode($rawBody, true);
http_response_code(200);
```

```ruby Ruby
require 'openssl'
require 'json'

def verify_webhook_signature(raw_body, signature, secret)
  expected = OpenSSL::HMAC.hexdigest('SHA256', secret, raw_body)
  Rack::Utils.secure_compare(expected, signature)
end

# Sinatra / Rails
post '/webhook' do
  raw_body  = request.body.read
  signature = request.env['HTTP_X_MORIBIZ_SIGNATURE']

  halt 401, 'Unauthorized' unless
    verify_webhook_signature(raw_body, signature, ENV['WEBHOOK_SECRET'])

  event = JSON.parse(raw_body)
  status 200
end
```

```go Go
import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"io"
	"net/http"
	"os"
)

func verifySignature(rawBody []byte, signature, secret string) bool {
	mac := hmac.New(sha256.New, []byte(secret))
	mac.Write(rawBody)
	expected := hex.EncodeToString(mac.Sum(nil))
	return hmac.Equal([]byte(expected), []byte(signature))
}

func webhookHandler(w http.ResponseWriter, r *http.Request) {
	body, _ := io.ReadAll(r.Body)
	signature := r.Header.Get("X-MoriBiz-Signature")

	if !verifySignature(body, signature, os.Getenv("WEBHOOK_SECRET")) {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}
	w.WriteHeader(http.StatusOK)
}
```

```java Java
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;
import java.util.HexFormat;

public static boolean verifySignature(String rawBody, String signature, String secret)
        throws Exception {
    Mac mac = Mac.getInstance("HmacSHA256");
    mac.init(new SecretKeySpec(secret.getBytes(), "HmacSHA256"));
    String expected = HexFormat.of().formatHex(mac.doFinal(rawBody.getBytes()));
    return MessageDigest.isEqual(expected.getBytes(), signature.getBytes());
}

// Spring Boot handler
@PostMapping("/webhook")
public ResponseEntity<Void> handleWebhook(
        @RequestBody String rawBody,
        @RequestHeader("X-MoriBiz-Signature") String signature) throws Exception {

    if (!verifySignature(rawBody, signature, webhookSecret)) {
        return ResponseEntity.status(401).build();
    }
    // process event...
    return ResponseEntity.ok().build();
}
```
</CodeGroup>

## Retry policy

If your endpoint doesn't return a `2xx` status code, BIZ MORI retries the delivery:

| Attempt | Delay |
|---------|-------|
| 1st retry | 1 second |
| 2nd retry | 2 seconds |
| 3rd retry | 4 seconds |

After 3 failed retries, the event is marked as `FAILED`. You can view failed events using the [List Webhook Events](/api-reference/webhooks/list-events) endpoint.

## Managing webhooks

| Action | Endpoint |
|--------|----------|
| List all webhooks | [GET /webhooks](/api-reference/webhooks/list-webhooks) |
| Create a webhook | [POST /webhooks](/api-reference/webhooks/create-webhook) |
| Get webhook details | [GET /webhooks/{id}](/api-reference/webhooks/get-webhook) |
| Update a webhook | [PUT /webhooks/{id}](/api-reference/webhooks/update-webhook) |
| Delete a webhook | [DELETE /webhooks/{id}](/api-reference/webhooks/delete-webhook) |
| View delivery events | [GET /webhooks/{id}/events](/api-reference/webhooks/list-events) |
